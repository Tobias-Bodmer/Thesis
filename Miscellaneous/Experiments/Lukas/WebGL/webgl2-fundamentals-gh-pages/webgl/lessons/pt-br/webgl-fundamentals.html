<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/pt-br/webgl-fundamentals.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="pt-br">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="Fundamentos da WebGL2" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webgl2fundamentals.org/webgl/lessons/resources/webgl2fundamentals.jpg" />
<meta property="og:description" content="Sua primeira lição da WebGL2: começando com os fundamentos" />
<meta property="og:url" content="http://webgl2fundamentals.org/webgl/lessons/pt-br/webgl-fundamentals.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webgl2fundamentals.org" />
<meta name="twitter:title" content="Fundamentos da WebGL2" />
<meta name="twitter:url" content="http://webgl2fundamentals.org/webgl/lessons/pt-br/webgl-fundamentals.html" />
<meta name="twitter:description" content="Sua primeira lição da WebGL2: começando com os fundamentos" />
<meta name="twitter:image:src" content="http://webgl2fundamentals.org/webgl/lessons/resources/webgl2fundamentals.jpg" />


<title>Fundamentos da WebGL2</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-fundamentals.html" >English</a>
    <option value="/webgl/lessons/de/webgl-fundamentals.html" >Deutsch</a>
    <option value="/webgl/lessons/ko/webgl-fundamentals.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-fundamentals.html" selected>Português Brasileiro</a>
</select>


    <a href="#toc">Índice</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/pt-br/">WebGL2Fundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>Fundamentos da WebGL2</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Primeiramente, esses artigos são sobre a WebGL2. Se você está interessado na WebGL 1.0
<a href="http://webglfundamentals.org">por favor, vá aqui</a>. Observe que a WebGL2 é <a href="webgl1-backward-compatibility.html">quase 100% compatível
com a WebGL1</a>. Dito isto, uma vez que você habilita a
WebGL2, você também pode usá-la como ela deveria ser usada. Esses tutoriais seguem esse raciocínio.</p>
<p><a href="#日本語のテクスト">test</a></p>
<p>Normalmente, a WebGL é vista como uma API 3D. As pessoas pensam: &quot;eu irei usar a WebGL e como uma mágica,
eu vou obter efeitos 3D super legais&quot;. Na realidade não é nada disso, a WebGL é apenas um mecanismo de rasterização. Ela desenha
pontos, linhas e triângulos com base no código que você fornece. Colocar a WebGL para fazer qualquer outra coisa depende de você
fornecer o código de modo que o uso dos pontos, linhas e triângulos sejam capazes de realizar sua tarefa.</p>
<h2 id="-">日本語のテクスト</h2>
<p>A WebGL é executada diretamente na GPU do seu computador. Como tal, você precisa indicar o código a ser executado na GPU.
Você pode indicar o código na forma de pares de funções. Essas 2 funções são chamadas de vexter shader
e fragment shader e cada uma delas está escrita em linguagem no estilo C/C++ estritamente tipada chamada
<a href="webgl-shaders-and-glsl.html">GLSL</a>. (GL Shader Language). Juntas, elas são chamadas de <em>programa</em>.</p>
<p>O trabalho da vertex shader é calcular as posições dos vértices. Com base nas posições que a função retornar,
o WebGL pode então rasterizar vários tipos de primitivas, incluindo pontos, linhas ou triângulos.
Ao rasterizar essas primitivas, ele chama uma segunda função fornecida pelo usuário chama fragment shader (sombreador de fragmento).
O trabalho do fragment shader é calcula uma cor para cada pixel da primitiva sendo atualmente desenhada.</p>
<p>Quase toda a API da WebGL se resume em configurar o estado para esses pares de funções a serem executadas.
Para cada coisa que você deseja desenhar, configure um grupo de estados e execute um par de funções, chamando
<code>gl.drawArrays</code> ou <code>gl.drawElements</code> que executa seus shaders (sombreadores) na GPU.</p>
<p>Todos os dados que você deseja que essas funções tenham acesso devem ser fornecidas à GPU.
Há quatro maneiras de como um shader é capaz de obter dados.</p>
<ol>
<li><p>Atributos, Buffers, e Vertex Arrays</p>
<p>Buffers são arrays de dados binários que você carrega na GPU. Normalmente, os buffers contêm
coisas como posições, normals, coordenadas de textura, cores de vértices, etc.
embora você esteja livre para colocar tudo o que quiser neles.</p>
<p>Os atributos são usados para especificar como   tirar dados dos seus buffers e fornecê-los para o seu vertex shader.
Por exemplo, você pode colocar posições em um buffer como 3 floats de 32bits
por posição. Você poderia dizer a um determinado atributo qual buffer irá extrair as posições, que tipo de
ele deve retirar (3 componentes de números de pontos flutuantes de 32 bits), qual offset
no buffer as posições se iniciam, e quantos bytes são necessários para obter de um a posição para o próximo.</p>
<p>Buffers não possuem acesso aleatórrio. Em vez disso, um vertex shaders é executado um número específico
de vezes. Cada vez que é executado, o próximo valor de cada buffer especificado é puxado
, e o seu valor é atribuído a um atributo.</p>
<p>O estado dos atributos, quais buffers usar para cada um e como extrair dados
desses buffers, é coletado em um vertex array object (VAO).</p>
</li>
<li><p>Uniforms</p>
<p>Uniforms são, efetivamente, variáveis globais que você configurou antes de executar o seu shader.</p>
</li>
<li><p>Texturas</p>
<p>As texturas são matrizes de dados que você pode acessar aleatoriamente no seu programa de sombreamento. A coisa mais
para se colocar em uma textura são dados de imagem, mas as apenas dados e podem facilmente
conter algo diferente das cores.</p>
</li>
<li><p>Varyings</p>
<p>As Varyings são uma maneira de um vertex shader passar dados para um fragment shader. Dependendo
do que está sendo renderizado, pontos, linhas, ou triângulos, os valores definidos em uma variável
por um vertex shader serão interpolados enquanto o fragment shader é executado.</p>
</li>
</ol>
<h2 id="webgl-hello-world">WebGL Hello World</h2>
<p>A WebGL se preocupa apenas com 2 coisas. Coordenadas do Clispace e cores.
Seu trabalho como programador usando a WebGL é fornecer WebGL com essas 2 coisas.
Você fornece seus 2 &quot;shaders&quot; para fazer isso. Um vexter shader que fornece fornece as
coordenadas do Clispace e um fragment shader que fornece a cor.</p>
<p>As coordenadas do Clispace sempre vão de -1 a +1, independentemente do tamanho do seu canvas.
Aqui está um simples exemplo da WebGL que a mostra em sua forma mais simples.</p>
<p>Vamos começar com um vertex shader</p>
<pre><code>#version 300 es

// um atributo é um input (in) para um vertex shader.
// ele receberá dados de um buffer
in vec4 a_position;

// todos os shaders possuem uma função main
void main() {

  // gl_Position é uma variável especial de um vertex shader
  // é responsável pela configuração
  gl_Position = a_position;
}
</code></pre><p>Quando executada, se toda a coisa fosse escrita em JavaScript em vez de GLSL
você poderia imaginar que isso seria utilizado como o exemplo abaixo</p>
<pre><code>// *** PSUEDO CÓDIGO!! ***

var positionBuffer = [
  0, 0, 0, 0,
  0, 0.5, 0, 0,
  0.7, 0, 0, 0,
];
var attributes = {};
var gl_Position;

drawArrays(..., offset, count) {
  var stride = 4;
  var size = 4;
  for (var i = 0; i &lt; count; ++i) {
     // copia os 4 próximos valores do positionBuffer para o atributo a_position
     attributes.a_position = positionBuffer.slice((offset + i) * stride, size);
     runVertexShader();
     ...
     doSomethingWith_gl_Position();
}
</code></pre><p>Na realidade, não é tão simples porque o <code>positionBuffer</code> precisa ser convertido em dados
binários (veja abaixo) e, portanto, o cálculo real para obter os dados do buffer
seria um pouco diferente, mas espero que isso lhe dê uma ideia de como um vertex shader
será executado.</p>
<p>Em seguida, nós precisamos de um fragment shader</p>
<pre><code>#version 300 es

// fragment shaders não tem uma precisão padrão, então nós precisamos
// escolher uma. mediump é um bom valor padrão. Do Inglês &quot;medium precision&quot;, significa &quot;precisão média&quot;
precision mediump float;

// precisamos declarar um output para o fragment shader
out vec4 outColor;

void main() {
  // Simplesmente defina o output para um constante com uma cor avermelhada-roxa
  outColor = vec4(1, 0, 0.5, 1);
}
</code></pre><p>Acima, nós declaramos <code>outColor</code> como um output do nosso fragment shader. Estamos definindo <code>outColor</code> com os valores <code>1, 0, 0.5, 1</code>
sendo 1 para vermelho, 0 para verde, 0.5 para azul, 1 para alpha. As cores na WebGL vão de 0 a 1.</p>
<p>Agora que nós escrevemos as duas funções shaders, vamos iniciar com a WebGL</p>
<p>Primeiro precisaremos de um elemento canvas do HTML</p>
<pre><code> &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
</code></pre><p>Então, em JavaScript, podemos obtê-lo da seguinte forma</p>
<pre><code> var canvas = document.getElementById(&quot;c&quot;);
</code></pre><p>Agora podemos criar um WebGL2RenderingContext</p>
<pre><code> var gl = canvas.getContext(&quot;webgl2&quot;);
 if (!gl) {
    // sem webgl2 pra você!
    ...
</code></pre><p>Agora precisamos compilar esses shaders para colocá-los na GPU, então primeiro precisaremos inseri-los em strings.
Você criar suas strings GLSL da maneira que você normalmente cria strings em JavaScript. Por exemplo, concatenando,
usando AJAX para obtê-las, colocando-as em tags de script non-javascript, ou neste caso,
em literais de templates multilinha.</p>
<pre><code>var vertexShaderSource = `#version 300 es

// um atributo é um input (in) para um vertex shader.
// ele receberá dados de um buffer
in vec4 a_position;

// todos os shaders possuem uma função main
void main() {

// gl_Position é uma variável especial de um vertex shader
// é responsável pela configuração
gl_Position = a_position;
}
`;

var fragmentShaderSource = `#version 300 es

// fragment shaders não tem uma precisão padrão, então nós precisamos
// escolher uma. mediump é um bom valor padrão. Do Inglês &quot;medium precision&quot;, significa &quot;precisão média&quot;
precision mediump float;

// precisamos declarar um output para o fragment shader
out vec4 outColor;

void main() {
  // Simplesmente defina o output para um constante com uma cor avermelhada-roxa
  outColor = vec4(1, 0, 0.5, 1);
}
`;
</code></pre><p>Na verdade, a maioria dos motores 3D geram shaders GLSL com case em vários tipos de templates, concatenação, etc.
Para as amostras neste site, nenhuma delas é suficientemente complexa para precisar
gerar GLSL em tempo de execução.</p>
<blockquote>
<p>NOTE: <code>#version 300 es</code> <strong>DEVE SER A PRIMEIRA LINHA DO SEUS SHADER</strong>. Nenhum comentário ou
linhas em branco são permitidas antes dele! <code>#version 300 es</code> diz para a WebGL2 que você deseja
usar a linguagem de shader da WebGL2, chamada GLSL ES 3.00. Se você não colocar isso como a primeira linha, a linguagem padrão
do shader será definida para a da WebGL 1.0, a GLSL ES 1.00 que possui muitas diferenças e bem menos recursos.</p>
</blockquote>
<p>Em seguida, precisamos de uma função que irá criar uma shader, faça o upload da fonte GLSL e compile o shader.
Note que eu não escrevi nenhum comentários visto que através do nome das funções é fácil
compreender o que está acontecendo.</p>
<pre><code>function createShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }

  console.log(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
}
</code></pre><p>Agora podemos chamar essa função para criar os 2 shaders</p>
<pre><code>var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
</code></pre><p>Nós, então, precisamos <em>linkar</em> aqueles 2 shaders em um <em>program</em></p>
<pre><code>function createProgram(gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }

  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}
</code></pre><p>E chame isso</p>
<pre><code>var program = createProgram(gl, vertexShader, fragmentShader);
</code></pre><p>Agora que criamos um programa GLSL na GPU, precisamos fornecer dados para ele.
A maioria da API da WebGL se trata de configurar o estado para fornecer dados aos nossos programas GLSL.
Nesse caso, nossa única entrada para o nosso programa GLSL é <code>a_position</code>, que por sua vez, é um atributo.
A primeira coisa que devemos fazer é procurar a localização do atributo para o programa
que nós acabamos de criar</p>
<pre><code>var positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
</code></pre><p>Procurar posições de atributos (e locais uniformes) é algo que você deve
fazer durante a inicialização, e não no seu loop de renderização.</p>
<p>Atributos obtêm seus dados através de buffers, então, nós precisamos criar um buffer</p>
<pre><code>var positionBuffer = gl.createBuffer();
</code></pre><p>A WebGL nos permite manipular muitos recursos da WebGL em pontos de consolidação global.
Você pode pensar em pontos de ligação como variáveis internas globais dentro da WebGL.
Primeiro, você vincula um recurso a um ponto de ligação. E então, todas as outras funções
ao recurso através do ponto de ligação. Então, vamos vincular o buffer de posição.</p>
<pre><code>gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
</code></pre><p>Agora podemos colocar dados nesse buffer, referenciando-o através do ponto de ligação</p>
<pre><code>// três pontos 2d
var positions = [
  0, 0,
  0, 0.5,
  0.7, 0,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
</code></pre><p>Há muita coisa acontecendo aqui. A primeira coisa que temos é <code>positions</code>, que é um
array em JavaScript. A WebGL, por outro lado, precisa de dados fortemente tipados, e então
a parte <code>new Float32Array(position)</code> cria uma nova matriz de números de pontos flutuantes de 32 bits
e copia os valores de <code>positions</code>. Então, <code>gl.bufferData</code> copia esses dados para o <code>positionBuffer</code> na GPU. O
buffer de posição está sendo usado porque nós o vinculamos ao ponto de ligação <code>ARRAY_BUFFER</code> acima.</p>
<p>O último argumento, <code>gl.STATIC_DRAW</code> é uma dica para a WebGL sobre como usaremos os dados.
A WebGL pode tentar usar essa sugestão para otimizar certas coisas. <code>gl.STATIC_DRAW</code> diz para a WebGL
que não é provável que mudemos muito esses dados.</p>
<p>Agora que colocamos dados em um buffer, precisamos mostrar ao atributo como obter os dados dele.
Primeiro, precisamos criar uma coleção do estado do atributo denominada Vertex Array Object.</p>
<pre><code>var vao = gl.createVertexArray();
</code></pre><p>E precisamos fazer com que ele seja o vertex array atual para que todas as nossas
configurações de atributos se apliquem a esse conjunto de estado de atributos</p>
<pre><code>gl.bindVertexArray(vao);
</code></pre><p>Finalmente, nós configuramos os atributos no vertex array. Em primeiro lugar, precisamos ativar o atributo.
Isso fala para a WebGL que queremos tirar dados de um buffer. Se não ativarmos o atributo, então, o atributo
terá um valor constante.</p>
<pre><code>gl.enableVertexAttribArray(positionAttributeLocation);
</code></pre><p>Então, nós precisamos especificar como obter os dados</p>
<pre><code>var size = 2;          // 2 componentes por iteração
var type = gl.FLOAT;   // os dados são floats de 32bits
var normalize = false; // não normalize os dados
var stride = 0;        // 0 = mover para frente size * sizeof(type) cada iteração para obter a próxima posição
var offset = 0;        // comece no início do buffer
gl.vertexAttribPointer(
    positionAttributeLocation, size, type, normalize, stride, offset)
</code></pre><p>Uma parte oculta da <code>gl.vertexAttribPointer</code> é que ela vincula o atual <code>ARRAY_BUFFER</code>
ao atributo. Em outras palavras, agora esse atributo é obrigado a vincular o <code>positionBuffer</code>.
Isso significa que estamos livres para ligar outra coisa ao ponto de ligação <code>ARRAY_BUFFER</code>;
O atributo continuará usando o <code>positionBuffer</code>.</p>
<p>Observe que, do ponto de vista do nosso GLSL vertex shader, o atributo <code>a_position</code> é um <code>vec4</code></p>
<pre><code>in vec4 a_position;
</code></pre><p><code>vec4</code> é um 4 float value. Em JavaScript, você poderia pensar em algo como
<code>a_position = {x: 0, y: 0, z: 0, w: 0}</code>. Acima, nós definimos <code>size = 2</code>. Atributos
padrão para <code>0, 0, 0, 1</code> então esse atributo receberá seus primeiros 2 valores (x e y)
do nosso buffer. O z e o w, será o padrão 0 e 1, respectivamente.</p>
<p>Antes de desenharmos, devemos redimensionar nosso canvas (ou nossa tela) para corresponder com o nosso tamanho de exibição. As telas, como as imagens, possuem 2 tamanhos.
O número real de pixels em si e separadamente o tamanho que eles são exibidos.
O CSS determina o tamanho que o canvas é exibido. <strong>Você sempre deve definir o tamanho que deseja
uma tela com o CSS</strong>, pois é muito mais flexível do que qualquer outro método.</p>
<p>Para fazer com que o número de pixels na tela coincida com o tamanho exibido
<a href="webgl-resizing-the-canvas.html">eu faço o uso de um helper, mais detalhes aqui</a>.</p>
<p>Em quase todas essas amostras, o tamanho da tela é de 400x300 pixels se a anistra for executada 
em sua própria janela, mas ela se estende para preencher o espaço disponível se estiver dentro de um iframe
como ele está nesta página.
Ao permitir que o CSS determine o tamanho e, em seguida, ajuste seus tamanho para  corresponder ao da tela,
nós facilmente manipulamos ambos os casos.</p>
<pre><code>webglUtils.resizeCanvasToDisplaySize(gl.canvas);
</code></pre><p>Precisamos dizer ao WebGL como converter valores do clip space,
nós vamos configurar o <code>gl_Position</code> de volta para pixels, muitas vezes chamado de screen space.
Para isso, chamamos <code>gl.viewport</code> e passamos o tamanho atual da tela (canvas).</p>
<pre><code>gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
</code></pre><p>Isso diz para a WebGL que o clip space -1 +1 mapeia para o 0 &lt;-&gt; <code>gl.canvas.width</code> para x e 0 &lt;-&gt; <code>gl.canvas.height</code>
para y.</p>
<p>Agora, nós limpamos nosso canvas. <code>0, 0, 0, 0</code> são vermelho, verde, azul, alpha, respectivamente, então, nesse caso, estamos definindo o canvas como transparente.</p>
<pre><code>// Limpar o canvas
gl.clearColor(0, 0, 0, 0);
gl.clear(gl.COLOR_BUFFER_BIT);
</code></pre><p>Em seguida, precisamos dizer ao WebGL qual shader é executado.</p>
<pre><code>// Fala para usar nosso program (par de shaders)
gl.useProgram(program);
</code></pre><p>Então precisamos informar qual é o conjunto de buffers usar e como obter os dados desses buffers
e então fornecer os dados aos atributos</p>
<pre><code>// Vincule o atributo/buffer que desejamos.
gl.bindVertexArray(vao);
</code></pre><p>Depois de tudo o que fizeemos, finalmente, podemos pedir a WebGL que execute o nosso programa GLSL.</p>
<pre><code>var primitiveType = gl.TRIANGLES;
var offset = 0;
var count = 3;
gl.drawArrays(primitiveType, offset, count);
</code></pre><p>Como a contagem é 3, isso executará o nosso vertex shader 3 vezes. A primeira vez <code>a_position.x</code> e <code>a_position.y</code>
em nosso atributo vertex shader será configurado para os dois primeiros valores do positionBuffer.
A segunda vez <code>a_position.xy</code> será configurado para os dois segundos valores. Na última vez, ele será
configurado para os últimos 2 valores.</p>
<p>Como definimos <code>primitiveType</code> para <code>gl.TRIANGLES</code>, cada vez que nosso vertex shader é executado 3 vezes,
a WebGL desenhará um triângulo com base nos 3 valores que definimos em <code>gl_Position</code>. Não importa o tamanho da
nossa tela, esses valores estão nas coordenadas do nosso clip space que vão de -1 a 1 em cada direção.</p>
<p>Como o nosso vertex shader está simplesmente copiando os valores do nosso positionbuffer para a <code>gl_Position</code>, o
o triângulo será desenhado nas coordenadas do clip space</p>
<pre><code>  0, 0,
  0, 0.5,
  0.7, 0,
</code></pre><p>Convertendo do clip space para o espaço da tela se o tamanho da tela
passasse ser 400x300, nós teríamos algo assim</p>
<pre><code> clip space      screen space
   0, 0       -&gt;   200, 150
   0, 0.5     -&gt;   200, 225
 0.7, 0       -&gt;   340, 150
</code></pre><p>A WebGL agora renderizará esse triângulo. Para cada pixel que está prestes a desenhar, a WebGL chamará o nosso fragment shader.
Nosso fragment shader apenas define a <code>outColor</code> para <code>1, 0, 0.5, 1</code>. Como o Canvas é um canvas de 8bits
por canal, significa que, a WebGL vai escrever os seguintes valores <code>[255, 0, 127, 255]</code> na tela.</p>
<p>Aqui está um exemplo já pronto</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-fundamentals.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-fundamentals.html" target="_blank">clique aqui para abrir em uma janela separada</a>
</div>

</p>
<p>No caso acima, você pode ver que o nosso vertex shader não está fazendo nada
além de passar nossos dados de posição diretamente. Como os dados da posição já
estão no clipspace, não há trabalho a fazer. <em>Se você quer objetos 3D, só depende de você
fornecer shaders que convertam de 3D para clipspace porque a WebGL é, apenas,
uma API de rasterização</em>.</p>
<p>Você pode estar se perguntando por que o triângulo começa no meio e vai para o canto superior direito.
O clip space em <code>x</code> vai de -1 a +1. Isso significa que o 0 está no centro e os valores positivos
irão para à direita dele.</p>
<p>Quanto ao porquê está no topo, o clip space -1 está na parte inferior e +1 está no topo.
Isso significa que, o 0 está no centro e os números positivos estarão acima do centro.</p>
<p>Para coisas 2D, você provavelmente iria preferir trabalhar em pixels do que com o clipspace
então vamos mudar o shader para que possamos fornecer a posição em pixels e
convertê-lo em um clipspace para nós. Aqui está o novo vertex shader</p>
<pre><code>-  in vec4 a_position;
+  in vec2 a_position;

+  uniform vec2 u_resolution;

  void main() {
+    // converte a posição dos pixels de 0.0 para 1.0
+    vec2 zeroToOne = a_position / u_resolution;
+
+    // converte de 0-&gt;1 para 0-&gt;2
+    vec2 zeroToTwo = zeroToOne * 2.0;
+
+    // converte de 0-&gt;2 para -1-&gt;+1 (clipspace)
+    vec2 clipSpace = zeroToTwo - 1.0;
+
*    gl_Position = vec4(clipSpace, 0, 1);
  }
</code></pre><p>Algumas coisas que devemos notar sobre as mudanças. Nós mudamos a <code>a_position</code> para um <code>vec2</code> já que nós
estamos apenas usando <code>x</code> e <code>y</code>. Um <code>vec2</code> é semelhante a um <code>vec4</code>, porém, possui apenas <code>x</code> e <code>y</code>.</p>
<p>Em seguida, adicionamos um <code>uniform</code> chamado <code>u_resolution</code>. Para definir que precisamos procurar por sua localização.</p>
<pre><code>var resolutionUniformLocation = gl.getUniformLocation(program, &quot;u_resolution&quot;);
</code></pre><p>O reste deve estar claro a partir dos comentários. Ao configurar <code>u_resolution</code> para a resolução
do nosso canvas, o shader vai agora tomar as posições que colocamos no <code>positionBuffer</code> fornecido
nas coordenadas dos pixels e convertê-los em clip space.</p>
<p>Agora podemos alterar os valores da nossa posição do clip space para pixels. Desta vez,
vamos desenhar um retângulo feito de 2 triângulos, 3 pontos, cada.</p>
<pre><code>var positions = [
*  10, 20,
*  80, 20,
*  10, 30,
*  10, 30,
*  80, 20,
*  80, 30,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
</code></pre><p>E depois de definirmos qual programa usar, podemos definir o valor do uniform que criamos.
<code>gl.useProgram</code> é como <code>gl.bindBuffer</code> acima, em que ele define o programa atual.
Depois de tudo, as funções <code>gl.uniformXXX</code> definem os uniforms no programa atual.</p>
<pre><code>gl.useProgram(program);

// Passa a resolução do canvas, assim nós podemos converter
// de pixels para clipspace no shader
gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
</code></pre><p>E, claro, para desenhar dois triângulos, precisamos que a WebGL chame nosso vertex shader 6 vezes,
para isso, precisamos mudar o <code>count</code> para <code>6</code>.</p>
<pre><code>// desenha
var primitiveType = gl.TRIANGLES;
var offset = 0;
*var count = 6;
gl.drawArrays(primitiveType, offset, count);
</code></pre><p>E aqui está</p>
<p>Nota: Este exemplo e todos os exemplos a seguir usam <a href="/webgl/resources/webgl-utils.js"><code>webgl-utils.js</code></a>
que contém funções para compilar e vincular os shaders. Não há nenhuma razão para desordenar os
exemplos com o <a href="webgl-boilerplate.html">boilerplate</a>.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle.html" target="_blank">clique aqui para abrir em uma janela separada</a>
</div>

</p>
<p>Novamente, você pode notar que o retângulo está perto do fundo dessa área. A WebGL considera que o canto 
inferior esquerdo é 0,0. Para que ele seja o tradicional canto superior esquerdo, usado nas APIS de gráficos
2D, nós podemos simplesmente virar a coordenada y do clipspace.</p>
<pre><code>*   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
</code></pre><p>E agora o nosso retângulo está aonde esperavamos.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangle-top-left.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangle-top-left.html" target="_blank">clique aqui para abrir em uma janela separada</a>
</div>

</p>
<p>Vamos fazer o código que define um retângulo em uma função para
podermos chamá-lo para retângulos de diferentes tamanhos. Enquanto estamos nisso,
nós tornaremos a cor ajustável.</p>
<p>Primeiro fazemos o fragment shader pegar uma color uniform input.</p>
<pre><code>#version 300 es

precision mediump float;

+  uniform vec4 u_color;

out vec4 outColor;

void main() {
-  outColor = vec4(1, 0, 0.5, 1);
*  outColor = u_color;
}
</code></pre><p>E aqui está o novo código que desenha 50 retângulos com cores e locais aleatórios.</p>
<pre><code>  var colorLocation = gl.getUniformLocation(program, &quot;u_color&quot;);
  ...

  // desenha 50 retângulos com cores e locais aleatórios
  for (var ii = 0; ii &lt; 50; ++ii) {
    // Define um retângulo aleatório
    setRectangle(
        gl, randomInt(300), randomInt(300), randomInt(300), randomInt(300));

    // Define uma cor aleatória.
    gl.uniform4f(colorLocation, Math.random(), Math.random(), Math.random(), 1);

    // Desenha o retângulo.
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 6;
    gl.drawArrays(primitiveType, offset, count);
  }
}

// Retorna um inteiro aleatório entre o intervalo de 0 e - 1.
function randomInt(range) {
  return Math.floor(Math.random() * range);
}

// Preenche o buffer com os valores que definem um retângulo.

function setRectangle(gl, x, y, width, height) {
  var x1 = x;
  var x2 = x + width;
  var y1 = y;
  var y2 = y + height;

  // NOTA: gl.bufferData(gl.ARRAY_BUFFER, ...) afetará
  // qualquer buffer que esteja vinculado ao `ARRAY_BUFFER`,
  // mas até agora temos apenas um buffer. Se tivessémos mais de um
  // buffer, gostaríamos de vincular este buffer a `ARRAY_BUFFER` primeiro.

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x1, y2,
     x2, y1,
     x2, y2]), gl.STATIC_DRAW);
}
</code></pre><p>E aqui está os retângulos.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-rectangles.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-rectangles.html" target="_blank">clique aqui para abrir em uma janela separada</a>
</div>

</p>
<p>Espero que você veja que a WebGL é realmente uma API bastante simples.
Tudo bem, simples pode ser a palavra errada. Mas o que ela faz é simples. Ela apenas
executa 2 funções fornecidas pelo usuário, um vertex shader e um fragment shader e
desenha triângulos, linhas ou pontos.
Embora possa ser mais complicado fazer uma abordagem 3D, essa complicação é
definida por você, o programador, sob a forma de shaders mais complexos.
A própria API da WebGL é apenas um rasterizador e, conceitualmente, bastante simples.</p>
<p>Cobrimos um pequeno exemplo que mostrou como fornecer dados em um atributo e 2 uniforms.
É comum ter múltiplos atributos e muitos uniforms. Perto do topo deste artigo
também mencionamos <em>varyings</em> e <em>texturas</em>. Isso aparecerá em lições subsequentes.</p>
<p>Antes de avançarmos, quero mencionar que para <em>a maioria das</em> aplicações em atualização
os dados em um buffer, como fizemos em <code>setRectangle</code>, não são comuns. Usei esso
exemplo porque pensei que era mais fácil de explicar porque mostra coordenadas de pixels
como entrada e demonstra como fazer uma pequena quantidade de cálculos na GLSL. Não é errado, há
muitos os casos em que isso é o certo a se fazer, mas você deve <a href="webgl-2d-translation.html">continuar lendo para descobrir
a maneira mais comum de posicionar, orientar e dimensionar coisas na WebGL</a>.</p>
<p>Se você é 100% leigo na WebGL e não tem ideia do que é GLSL ou shaders ou o que a GPU faz, então,
em seguida, verifique [os conceitos básicos de como a WebGL realmente funciona] (webgl-how-it-works.html).(webgl-how-it-works.html).</p>
<p>Você também deve, pelo menos, ler brevemente sobre <a href="webgl-boilerplate.html">o código boilerplate usado aqui</a>
que é usado na maioria dos exemplos. Você também deve, pelo menos ver
<a href="webgl-drawing-multiple-things.html">como desenhar múltiplas coisas</a> para ter uma ideia de como
as aplicações em WebGL são estruturadas porque, infelizmente, apenas desenha algo e, portanto, não mostra essa estrutura.</p>
<p>Caso contrário, a partir daqui você pode ir em duas direções. Se você está interessado em processar imagens
Vou lhes mostrar <a href="webgl-image-processing.html">como fazer algum processamento de imagem 2D</a>.
Se você está interessado em aprender sobre translação, rotação e escala, então,
<a href="webgl-2d-translation.html">comece aqui</a>.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-fundamentals.html" >English</a>
    <option value="/webgl/lessons/de/webgl-fundamentals.html" >Deutsch</a>
    <option value="/webgl/lessons/ko/webgl-fundamentals.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-fundamentals.html" selected>Português Brasileiro</a>
</select>


        <div id="toc">
          <ul>
  <li>Fundamentos</li>
  <ul>
    <li><a href="/webgl/lessons/pt-br/webgl-getting-webgl2.html">Como utilizar a WebGL2</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-fundamentals.html">Fundamentos da WebGL2</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-how-it-works.html">Como Funciona a WebGL2</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-shaders-and-glsl.html">WebGL2 Shaders e GLSL</a></li>
  </ul>
  <li>WebGL2 vs WebGL1</li>
  <ul>
    <li><a href="/webgl/lessons/pt-br/webgl2-whats-new.html">O que há de novo na WebGL2</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl1-to-webgl2.html">Migrando do WebGL1 para a WebGL2</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl1-to-webgl2-fundamentals.html">Diferenças entre a WebGLFundamentals.org e a WebGL2Fundamentals.org</a></li>
  </ul>
  <li>Processamento de Imagem</li>
  <ul>
    <li><a href="/webgl/lessons/pt-br/webgl-image-processing.html">Processamento de Imagem WebGL2</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-image-processing-continued.html">Processamento de Imagem Continuada WebGL2</a></li>
  </ul>
  <li>Translação 2D, rotação, escala, matriz matemática</li>
  <ul>
    <li><a href="/webgl/lessons/pt-br/webgl-2d-translation.html">Translação 2D WebGL2</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-2d-rotation.html">Rotação 2D WebGL2</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-2d-scale.html">Escala 2D WebGL2</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-2d-matrices.html">Matrizes 2D WebGL2</a></li>
  </ul>
  <li>3D</li>
  <ul>
    <li><a href="/webgl/lessons/pt-br/webgl-3d-orthographic.html">WebGL2 - 3D ortogonal</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-3d-perspective.html">WebGL2 Perspectiva 3D</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-3d-camera.html">WebGL2 3D - Câmeras</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-matrix-naming.html">WebGL2 3D - Nomenclatura das Matrizes</a></li>
  </ul>
  <li>Iluminação</li>
  <ul>
    <li><a href="/webgl/lessons/pt-br/webgl-3d-lighting-directional.html">WebGL2 3D - Iluminação Direcional</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-3d-lighting-point.html">WebGL2 3D - Iluminação de Pontos</a></li>
  </ul>
  <li>Estrutura e Organização</li>
  <ul>
    <li><a href="/webgl/lessons/pt-br/webgl-less-code-more-fun.html">WebGL2 - Menos Código, Mais Diversão</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-drawing-multiple-things.html">WebGL2 - Desenhando Múltiplas Coisas</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-scene-graph.html">WebGL2 - Gráficos de Cena</a></li>
  </ul>
  <li>Geometria</li>
  <ul>
    <li><a href="/webgl/lessons/pt-br/webgl-3d-geometry-lathe.html">WebGL2 Geometria 3D - Torno</a></li>
  </ul>
  <li>Texturas</li>
  <ul>
    <li><a href="/webgl/lessons/pt-br/webgl-3d-textures.html">WebGL2 3D - Texturas</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-data-textures.html">WebGL2 - Textura de Dados</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-2-textures.html">WebGL2 - Usando 2 ou Mais Texturas</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-cors-permission.html">WebGL2 - Cross Origin Images</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-3d-perspective-correct-texturemapping.html">WebGL2 3D - Perspective Correct Texture Mapping</a></li>
  </ul>
  <li>Renderizando Uma Textura</li>
  <ul>
    <li><a href="/webgl/lessons/pt-br/webgl-render-to-texture.html">WebGL2 - Renderizar Uma Textura</a></li>
  </ul>
  </li>
  <li>Técnicas</li>
  <ul>
    <li>2D</li>
    <ul>
      <li><a href="/webgl/lessons/pt-br/webgl-2d-drawimage.html">WebGL2 2D - DrawImage</a>
      <li><a href="/webgl/lessons/pt-br/webgl-2d-matrix-stack.html">WebGL2 2D - Matrix Stack</a>
    </ul>
    <li>Text</li>
    <ul>
      <li><a href="/webgl/lessons/pt-br/webgl-text-html.html">WebGL2 Text - HTML</a>
      <li><a href="/webgl/lessons/pt-br/webgl-text-canvas2d.html">WebGL2 Text - Canvas 2D</a>
      <li><a href="/webgl/lessons/pt-br/webgl-text-texture.html">WebGL2 Text - Usando Uma Textura</a>
      <li><a href="/webgl/lessons/pt-br/webgl-text-glyphs.html">WebGL2 Text - Usando uma Textura Glyph</a>
    </ul>
  </ul>
  <li>Diversos</li>
  <ul>
    <li><a href="/webgl/lessons/pt-br/webgl-setup-and-installation.html">WebGL2 Configuração e Instalação</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-boilerplate.html">WebGL2 Boilerplate</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-resizing-the-canvas.html">WebGL2 Redimensionando o Canvas</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-animation.html">WebGL2 - Animação</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-and-alpha.html">WebGL2 e o Alpha</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-2d-vs-3d-library.html">WebGL2 - Bibliotecas 2D vs 3D</a></li>
    <li><a href="/webgl/lessons/pt-br/webgl-anti-patterns.html">WebGL2 - Anti-Patterns</a></li>
  </ul>
</ul>
<ul>
  <li><a href="/docs/">Documentação da API</a></li>
  <li><a href="http://twgljs.org">TWGL, Uma Pequena Biblioteca Auxiliar da WebGL</a></li>
  <li><a href="https://github.com/greggman/webgl2-fundamentals">github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>Dúvidas? <a href="http://stackoverflow.com/questions/tagged/webgl2">Pergunte no stackoverflow</a>.</div>
        <div>Problemas/Bug? <a href="http://github.com/greggman/webgl2-fundamentals/issues">Pergunte no github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Fundamentos da WebGL2';
            var disqus_title = 'Fundamentos da WebGL2';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-90754717-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



