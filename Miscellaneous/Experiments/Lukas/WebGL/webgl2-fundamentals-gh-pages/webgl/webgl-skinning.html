<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>WebGL2 - Skinning</title>
<link type="text/css" href="resources/webgl-tutorials.css" rel="stylesheet" />
</head>
<body>
<canvas id="canvas"></canvas>
</body>
<!--
This sample uses TWGL (Tiny WebGL) to hide the clutter.
Otherwise the sample would be full of code not related to the point of the sample.
For more info see http://webgl2fundamentals.org/webgl/lessons/webgl-less-code-more-fun.html
-->
<script src="resources/twgl-full.min.js"></script>
<script src="resources/m4.js"></script>
<script>
"use strict";

const simpleVertexShaderSource = `#version 300 es
in vec4 position;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

void main() {
  gl_Position = projection * view * model * position;
}
`;

const skinningVertexShaderSource = `#version 300 es

in vec4 position;
in vec4 weight;
in vec4 boneNdx;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 bones[4];

void main() {

  gl_Position = projection * view *
                (bones[int(boneNdx[0])] * position * weight[0] +
                 bones[int(boneNdx[1])] * position * weight[1] +
                 bones[int(boneNdx[2])] * position * weight[2] +
                 bones[int(boneNdx[3])] * position * weight[3]);

}
`;

const fragmentShaderSource = `#version 300 es
precision mediump float;

uniform vec4 color;

out vec4 outColor;

void main () {
  outColor = color;
}
`;

function main() {
  // Get A WebGL context
  /** @type {HTMLCanvasElement} */
  var canvas = document.getElementById("canvas");
  var gl = canvas.getContext("webgl2");
  if (!gl) {
    return;
  }

  // Use our boilerplate utils to compile the shaders and link into a program
  const skinningProgramInfo = twgl.createProgramInfo(
      gl, [skinningVertexShaderSource, fragmentShaderSource]);

  var arrays = {
    position: {
      numComponents: 2,
      data: [
       0,  1,  // 0
       0, -1,  // 1
       2,  1,  // 2
       2, -1,  // 3
       4,  1,  // 4
       4, -1,  // 5
       6,  1,  // 6
       6, -1,  // 7
       8,  1,  // 8
       8, -1,  // 9
      ],
    },
    boneNdx: {
      numComponents: 4,
      data: [
        0, 0, 0, 0,  // 0
        0, 0, 0, 0,  // 1
        0, 1, 0, 0,  // 2
        0, 1, 0, 0,  // 3
        1, 0, 0, 0,  // 4
        1, 0, 0, 0,  // 5
        1, 2, 0, 0,  // 6
        1, 2, 0, 0,  // 7
        2, 0, 0, 0,  // 8
        2, 0, 0, 0,  // 9
      ],
    },
    weight: {
      numComponents: 4,
      data: [
       1,  0, 0, 0,  // 0
       1,  0, 0, 0,  // 1
      .5, .5, 0, 0,  // 2
      .5, .5, 0, 0,  // 3
       1,  0, 0, 0,  // 4
       1,  0, 0, 0,  // 5
      .5, .5, 0, 0,  // 6
      .5, .5, 0, 0,  // 7
       1,  0, 0, 0,  // 8
       1,  0, 0, 0,  // 9
      ],
    },

    indices: [
      0, 1,
      0, 2,
      1, 3, //
      2, 3,
      2, 4,
      3, 5, //
      4, 5,
      4, 6,
      5, 7, //
      6, 7,
      6, 8,
      7, 9,
      8, 9,
    ],
  };

  var skinningBufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

  // Create a vertex array object (attribute state)
  var skinningVao = gl.createVertexArray();
  // and make it the one we're currently working with
  gl.bindVertexArray(skinningVao);
  // set all the attributes
  twgl.setBuffersAndAttributes(gl, skinningProgramInfo, skinningBufferInfo);

  var boneArray = new Float32Array(4 * 16);

  var uniforms = {
    projection: m4.orthographic(-20, 20, -10, 10, -1, 1),
    view: m4.translation(-6, 0, 0),
    bones: boneArray,
    color: [1, 0, 0, 1],
  };

  // make views for each bone. This lets all the bones
  // exist in 1 array for uploading but as separate
  // arrays for using with the math functions
  var boneUniforms = [];  // the uniform data
  var bones = [];         // the value before multiplying by inverse bind matrix
  var bindPose = [];      // the bind matrix
  for (var i = 0; i < 4; ++i) {
    boneUniforms.push(new Float32Array(boneArray.buffer, i * 4 * 16, 16));
    bindPose.push(m4.identity());  // just allocate storage
    bones.push(m4.identity());     // just allocate storage
  }

   // rotate each bone by a and simulate a hierarchy
   function computeBoneMatrices(bones, a) {
    var m = m4.identity();
    m4.zRotate(m, a, bones[0]);
    m4.translate(bones[0], 4, 0, 0, m);
    m4.zRotate(m, a, bones[1]);
    m4.translate(bones[1], 4, 0, 0, m);
    m4.zRotate(m, a, bones[2]);
    // bones[3] is not used
  }

  // compute the initial positions of each matrix
  computeBoneMatrices(bindPose, 0);

  // compute their inverses
  var bindPoseInv = bindPose.map(function(m) {
    return m4.inverse(m);
  });

  function render(time) {
    twgl.resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    var t = time * 0.001;
    var a = Math.sin(t) * 0.8;
    computeBoneMatrices(bones, a);

    // multiply each by its bindPoseInverse
    bones.forEach(function(bone, ndx) {
      m4.multiply(bone, bindPoseInv[ndx], boneUniforms[ndx]);
    });

    gl.useProgram(skinningProgramInfo.program);
    gl.bindVertexArray(skinningVao);
    twgl.setUniforms(skinningProgramInfo, uniforms);
    twgl.drawBufferInfo(gl, skinningBufferInfo, gl.LINES);

    drawAxis(uniforms.projection, uniforms.view, bones);

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);


  // --- ignore below this line - it's not relevant to the answer and it's a bad example ---

  var axisProgramInfo;
  var axisBufferInfo;
  var axisVao;
  function drawAxis(projection, view, bones) {
    if (!axisProgramInfo) {
      axisProgramInfo = twgl.createProgramInfo(gl, [simpleVertexShaderSource, fragmentShaderSource]);
      axisBufferInfo  = twgl.createBufferInfoFromArrays(gl, {
        position: {
          numComponents: 2,
          data: [
            0, 0,
            1, 0,
          ],
        },
      });
      // Create a vertex array object (attribute state)
      axisVao = gl.createVertexArray();
      // and make it the one we're currently working with
      gl.bindVertexArray(axisVao);
      // set all the attributes
      twgl.setBuffersAndAttributes(gl, axisProgramInfo, axisBufferInfo);
    }

    var uniforms = {
      projection: projection,
      view: view,
    };

    gl.useProgram(axisProgramInfo.program);
    gl.bindVertexArray(axisVao);

    for (var i = 0; i < 3; ++i) {
      drawLine(bones[i], 0, [0, 1, 0, 1]);
      drawLine(bones[i], Math.PI * 0.5, [0, 0, 1, 1]);
    }

    function drawLine(mat, angle, color) {
      uniforms.model = m4.zRotate(mat, angle);
      uniforms.color = color;
      twgl.setUniforms(axisProgramInfo, uniforms);
      twgl.drawBufferInfo(gl, axisBufferInfo, gl.LINES);
    }
  }
}

main();
</script>
</html>



