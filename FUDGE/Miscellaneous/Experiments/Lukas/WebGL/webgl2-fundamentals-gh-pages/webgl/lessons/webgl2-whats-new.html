<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl2-whats-new.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL2 What&#x27;s New" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webgl2fundamentals.org/webgl/lessons/resources/webgl2fundamentals.jpg" />
<meta property="og:description" content="What&#x27;s new in WebGL2" />
<meta property="og:url" content="http://webgl2fundamentals.org/webgl/lessons/webgl2-whats-new.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webgl2fundamentals.org" />
<meta name="twitter:title" content="WebGL2 What&#x27;s New" />
<meta name="twitter:url" content="http://webgl2fundamentals.org/webgl/lessons/webgl2-whats-new.html" />
<meta name="twitter:description" content="What&#x27;s new in WebGL2" />
<meta name="twitter:image:src" content="http://webgl2fundamentals.org/webgl/lessons/resources/webgl2fundamentals.jpg" />


<title>WebGL2 What&#x27;s New</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl2-whats-new.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl2-whats-new.html" >Deutsch</a>
    <option value="/webgl/lessons/ko/webgl2-whats-new.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl2-whats-new.html" >Português Brasileiro</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGL2Fundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 What&#x27;s New</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>WebGL2 is a pretty significant upgrade from WebGL1.
If you&#39;re coming from WebGL1 and you want to know
how to adjust your code so you can take advantage
of WebGL2 <a href="webgl1-to-webgl2.html">see this article</a>.</p>
<p>Here&#39;s the short list in no particular order</p>
<h2 id="vertex-array-objects-always-available">Vertex Array Objects always available</h2>
<p>I think this is fairly important even though it
was optionally available on WebGL1 now that it&#39;s
always available on WebGL2 <a href="webgl1-to-webgl2.html#Vertex-Array-Objects">I think you should probably
always use them</a>.</p>
<h2 id="the-size-of-a-texture-is-available-to-shaders-">The size of a texture is available to shaders.</h2>
<p>In WebGL1 if your shader needed to know the size of
a texture you had to pass the size in uniform manually.
In WebGL2 you can call</p>
<pre><code>vec2 size = textureSize(sampler, lod)
</code></pre><p>To get the size of any lod of a texture</p>
<h2 id="direct-texel-lookup">Direct Texel Lookup</h2>
<p>It&#39;s often convenient to store large arrays of data in a texture.
In WebGL 1 you could do that but you could only address textures
with texture coordinates (0.0 to 1.0). In WebGL2 you can look
up values from a texture by pixel/texel coordinates directly
making array access slightly easier</p>
<pre><code>vec4 values = texelFetch(sampler, ivec2Position, lod);
</code></pre><h2 id="lots-of-texture-formats">Lots of texture formats</h2>
<p>WebGL1 had just a few texture formats. WebGL2 has TONS!</p>
<ul>
<li><code>RGBA32I</code></li>
<li><code>RGBA32UI</code></li>
<li><code>RGBA16I</code></li>
<li><code>RGBA16UI</code></li>
<li><code>RGBA8</code></li>
<li><code>RGBA8I</code></li>
<li><code>RGBA8UI</code></li>
<li><code>SRGB8_ALPHA8</code></li>
<li><code>RGB10_A2</code></li>
<li><code>RGB10_A2UI</code></li>
<li><code>RGBA4</code></li>
<li><code>RGB5_A1</code></li>
<li><code>RGB8</code></li>
<li><code>RGB565</code></li>
<li><code>RG32I</code></li>
<li><code>RG32UI</code></li>
<li><code>RG16I</code></li>
<li><code>RG16UI</code></li>
<li><code>RG8</code></li>
<li><code>RG8I</code></li>
<li><code>RG8UI</code></li>
<li><code>R32I</code></li>
<li><code>R32UI</code></li>
<li><code>R16I</code></li>
<li><code>R16UI</code></li>
<li><code>R8</code></li>
<li><code>R8I</code></li>
<li><code>R8UI</code></li>
<li><code>RGBA32F</code></li>
<li><code>RGBA16F</code></li>
<li><code>RGBA8_SNORM</code></li>
<li><code>RGB32F</code></li>
<li><code>RGB32I</code></li>
<li><code>RGB32UI</code></li>
<li><code>RGB16F</code></li>
<li><code>RGB16I</code></li>
<li><code>RGB16UI</code></li>
<li><code>RGB8_SNORM</code></li>
<li><code>RGB8I</code></li>
<li><code>RGB8UI</code></li>
<li><code>SRGB8</code></li>
<li><code>R11F_G11F_B10F</code></li>
<li><code>RGB9_E5</code></li>
<li><code>RG32F</code></li>
<li><code>RG16F</code></li>
<li><code>RG8_SNORM</code></li>
<li><code>R32F</code></li>
<li><code>R16F</code></li>
<li><code>R8_SNORM</code></li>
<li><code>DEPTH_COMPONENT32F</code></li>
<li><code>DEPTH_COMPONENT24</code></li>
<li><code>DEPTH_COMPONENT16</code></li>
</ul>
<h2 id="3d-textures">3D Textures</h2>
<p>3D texture are just that. Textures that have 3 dimensions.</p>
<h2 id="texture-arrays">Texture arrays</h2>
<p>A texture array is very similar to a 3D texture except that
each slice is considered a separate texture. All the slices
have to be the same size but this is a great way to give
a shader access to hundreds of textures even though it
only has a relatively small number of texture units. You can
select the slice in your shader</p>
<pre><code>vec4 color = texture(someSampler2DArray, vec3(u, v, slice));
</code></pre><h2 id="non-power-of-2-texture-support">Non-Power of 2 Texture Support</h2>
<p>In WebGL1 textures that were not a power of 2 could not have mips.
In WebGL2 that limit is removed. Non-power of 2 texture work exactly
the same as power of 2 textures.</p>
<h2 id="loop-restrictions-in-shaders-removed">Loop restrictions in shaders removed</h2>
<p>In WebGL1 a loop in a shader had to use a constant integer expression.
WebGL2 removes that limit (in GLSL 300 es)</p>
<h2 id="matrix-functions-in-glsl">Matrix functions in GLSL</h2>
<p>In WebGL1 if needed to get the inverse of a matrix you had to
pass it in as a uniform. In WebGL2 GLSL 300 es there&#39;s the built in
<code>inverse</code> function as well as <code>transpose</code>.</p>
<h2 id="common-compressed-textures">Common compressed textures</h2>
<p>In WebGL1 there are various compressed texture formats
that are hardware dependent. S3TC was basically desktop only.
PVTC was iOS only. Etc..</p>
<p>In WebGL2 these formats are supposed to be supported everywhere</p>
<ul>
<li><code>COMPRESSED_R11_EAC RED</code></li>
<li><code>COMPRESSED_SIGNED_R11_EAC RED</code></li>
<li><code>COMPRESSED_RG11_EAC RG</code></li>
<li><code>COMPRESSED_SIGNED_RG11_EAC RG</code></li>
<li><code>COMPRESSED_RGB8_ETC2 RGB</code></li>
<li><code>COMPRESSED_SRGB8_ETC2 RGB</code></li>
<li><code>COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA</code></li>
<li><code>COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA</code></li>
<li><code>COMPRESSED_RGBA8_ETC2_EAC RGBA</code></li>
<li><code>COMPRESSED_SRGB8_ALPHA8_ETC2_EAC</code></li>
</ul>
<h2 id="uniform-buffer-objects">Uniform Buffer Objects</h2>
<p>Uniform Buffer Objects let you specify a bunch of uniforms
from a buffer. The advantages are</p>
<ol>
<li><p>You can manipulate all the uniforms in the buffer
outside of WebGL</p>
<p>In WebGL1 if you had 16 uniforms that would require
16 calls to <code>gl.uniformXXX</code>. That is relatively slow.
In WebGL2 if you use
a Uniform Buffer Object you can set the values in
a typed array all inside JavaScript which means it&#39;s
much much faster. When all the values are set
you upload them all with 1 call to <code>gl.bufferData</code>
or <code>gl.bufferSubData</code> and then tell the program
to use that buffer with <code>gl.bindBufferRange</code> so only
2 calls.</p>
</li>
<li><p>You can have different sets of uniforms buffer objects</p>
<p>First some terms. A Uniform Block is a collection
of uniforms defined in a shader. A Uniform Buffer Object
is a buffer that contains the values a Uniform Block
will use. You can create as many Uniform Buffer Objects
as you want and bind one of them to a particular Uniform Block
when you draw.</p>
<p>For example, you could have 4 uniform blocks defined
in a shader.</p>
<ul>
<li><p>A global matrix uniform block that contains
matrices that are the same for all draw calls like the
projection matrix, view matrix, etc.</p>
</li>
<li><p>A per model uniform block that contains matrices that are
different per model for example the world matrix and
normal matrix.</p>
</li>
<li><p>A material uniform block that contains the material settings
like diffuse, ambient, specular, etc..</p>
</li>
<li><p>A lighting uniform block that contains the lighting data
like light color, light position, etc..</p>
</li>
</ul>
<p>Then at runtime you could create one global uniform buffer
object, one model uniform buffer object per model, one
light uniform buffer object per light and one uniform buffer
object per material.</p>
<p>To draw any particular item assuming all the values are
already up to date all you have to do is bind your desired
4 uniform buffer objects</p>
<pre><code>gl.bindBufferRange(..., globalBlockIndx, globalMatrixUBO, ...);
gl.bindBufferRange(..., modelBlockIndx, someModelMatrixUBO, ...);
gl.bindBufferRange(..., materialBlockIndx, someMaterialSettingsUBO, ...);
gl.bindBufferRange(..., lightBlockIndx, someLightSettingsUBO, ...);
</code></pre></li>
</ol>
<h2 id="integer-textures-attributes-and-math">Integer textures, attributes and math</h2>
<p>In WebGL2 you can have integer based textures where as
in WebGL1 all textures represented floating point values
even if they weren&#39;t represented by floating point values.</p>
<p>You can also have integer attributes.</p>
<p>On top of that, GLSL 300 es allows you to do bit manipulations
of integers in the shaders.</p>
<h2 id="transform-feedback">Transform feedback</h2>
<p>WebGL2 allows your vertex shader to write its results back
to a buffer.</p>
<h2 id="samplers">Samplers</h2>
<p>In WebGL1 all the texture parameters were per texture.
In WebGL2 you can optionally use sampler objects. With
samplers, all the filtering and repeat/clamping parameters
that were part of a texture move to the sampler. This means
a single texture can be sampled in different ways. Repeating
or clamped. Filtered or not filtered.</p>
<p>A mini side rant: I&#39;ve written 6 game engines. I&#39;ve never
personally ever had an artist need to filter textures in
multiple ways. I&#39;d be curious to know if any other game
engine devs have had a different experience.</p>
<h2 id="depth-textures">Depth Textures</h2>
<p>Depth textures were optional in WebGL1 and a PITA to work around. Now they&#39;re standard.
Commonly used for computing shadow maps</p>
<h2 id="standard-derivatives">Standard Derivatives</h2>
<p>These are now standard. Common uses include computing normals in the shaders instead of passing them in</p>
<h2 id="instanced-drawing">Instanced Drawing</h2>
<p>Now Standard, common uses are drawing lots of trees, bushes or grass quickly.</p>
<h2 id="unsigned_int-indices">UNSIGNED_INT indices</h2>
<p>Being able to use 32bit ints for indices removes the size limit of indexed geometry</p>
<h2 id="setting-gl_fragdepth-">Setting <code>gl_FragDepth</code></h2>
<p>Letting you write your own custom values to the depth buffer / z-buffer.</p>
<h2 id="blend-equation-min-max">Blend Equation MIN / MAX</h2>
<p>Being able to take the min or max of 2 colors when blending</p>
<h2 id="multiple-draw-buffers">Multiple Draw Buffers</h2>
<p>Being able to draw to multiple buffers at once from a shader. This is commonly used
for various deferred rendering techniques.</p>
<h2 id="texture-access-in-vertex-shaders">Texture access in vertex shaders</h2>
<p>In WebGL1 this was an optional feature. There was a count of how many textures
you could access in a vertex shader and that count was allowed to be 0. Most
devices supported them. In WebGL2 that count is required to be at least 16.</p>
<h2 id="multi-sampled-renderbuffers">Multi-Sampled renderbuffers</h2>
<p>In WebGL1 the canvas itself could be anti-aliased with the GPU&#39;s built in
multi-sample system but there was no support for user controlled multi-sampling. In WebGL2
you can now make multi-sampled renderbuffers.</p>
<h2 id="occlusion-queries">Occlusion Queries</h2>
<p>Occlusion queries let you ask the GPU to check if it were to render something
would any pixels actually get drawn.</p>
<h2 id="floating-point-textures-always-available">Floating point textures always available</h2>
<p>Floating point textures are used for many special effects
and calculations. In WebGL1 they were optional. In WebGL2
they just exist.</p>
<p>Note: Unfortunately they are still restricted in that filtering
and rendering to float point textures is still optional. See
<a href="https://www.khronos.org/registry/webgl/extensions/OES_texture_float_linear/"><code>OES_texture_float_linear</code></a>
 and <a href="https://www.khronos.org/registry/webgl/extensions/EXT_color_buffer_float/"><code>EXT_color_buffer_float</code></a>.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl2-whats-new.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl2-whats-new.html" >Deutsch</a>
    <option value="/webgl/lessons/ko/webgl2-whats-new.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl2-whats-new.html" >Português Brasileiro</a>
</select>


        <div id="toc">
          <ul>
  <li>Fundamentals</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-getting-webgl2.html">How to use WebGL2</a></li>
    <li><a href="/webgl/lessons/webgl-fundamentals.html">WebGL2 Fundamentals</a></li>
    <li><a href="/webgl/lessons/webgl-how-it-works.html">WebGL2 How It Works</a></li>
    <li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">WebGL2 Shaders and GLSL</a></li>
  </ul>
  <li>WebGL2 vs WebGL1</li>
  <ul>
    <li><a href="/webgl/lessons/webgl2-whats-new.html">What's new in WebGL2</a></li>
    <li><a href="/webgl/lessons/webgl1-to-webgl2.html">Moving from WebGL1 to WebGL2</a></li>
    <li><a href="/webgl/lessons/webgl1-to-webgl2-fundamentals.html">Differences from WebGLFundamentals.org to WebGL2Fundamentals.org</a></li>
  </ul>
  <li>Image Processing</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-image-processing.html">WebGL2 Image Processing</a></li>
    <li><a href="/webgl/lessons/webgl-image-processing-continued.html">WebGL2 Image Processing Continued</a></li>
  </ul>
  <li>2D translation, rotation, scale, matrix math</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-2d-translation.html">WebGL2 2D Translation</a></li>
    <li><a href="/webgl/lessons/webgl-2d-rotation.html">WebGL2 2D Rotation</a></li>
    <li><a href="/webgl/lessons/webgl-2d-scale.html">WebGL2 2D Scale</a></li>
    <li><a href="/webgl/lessons/webgl-2d-matrices.html">WebGL2 2D Matrices</a></li>
  </ul>
  <li>3D</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-orthographic.html">WebGL2 - Orthographic 3D</a></li>
    <li><a href="/webgl/lessons/webgl-3d-perspective.html">WebGL2 3D Perspective</a></li>
    <li><a href="/webgl/lessons/webgl-3d-camera.html">WebGL2 3D - Cameras</a></li>
    <li><a href="/webgl/lessons/webgl-matrix-naming.html">WebGL2 3D - Matrix Naming</a></li>
  </ul>
  <li>Lighting</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">WebGL2 3D - Directional Lighting</a></li>
    <li><a href="/webgl/lessons/webgl-3d-lighting-point.html">WebGL2 3D - Point Lighting</a></li>
    <li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">WebGL2 3D - Spot Lighting</a></li>
  </ul>
  <li>Structure and Organization</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">WebGL2 - Less Code, More Fun</a></li>
    <li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">WebGL2 - Drawing Multiple Things</a></li>
    <li><a href="/webgl/lessons/webgl-scene-graph.html">WebGL2 - Scene Graphs</a></li>
  </ul>
  <li>Geometry</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">WebGL2 3D Geometry - Lathe</a></li>
  </ul>
  <li>Textures</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-textures.html">WebGL2 3D - Textures</a></li>
    <li><a href="/webgl/lessons/webgl-data-textures.html">WebGL2 - Data Textures</a></li>
    <li><a href="/webgl/lessons/webgl-2-textures.html">WebGL2 - Using 2 or More Textures</a></li>
    <li><a href="/webgl/lessons/webgl-cors-permission.html">WebGL2 - Cross Origin Images</a></li>
    <li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">WebGL2 3D - Perspective Correct Texture Mapping</a></li>
  </ul>
  <li>Rendering To A Texture</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-render-to-texture.html">WebGL2 - Render to Texture</a></li>
  </ul>
  </li>
  <li>Techniques</li>
  <ul>
    <li>2D</li>
    <ul>
      <li><a href="/webgl/lessons/webgl-2d-drawimage.html">WebGL2 2D - DrawImage</a>
      <li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">WebGL2 2D - Matrix Stack</a>
    </ul>
    <li>Text</li>
    <ul>
      <li><a href="/webgl/lessons/webgl-text-html.html">WebGL2 Text - HTML</a>
      <li><a href="/webgl/lessons/webgl-text-canvas2d.html">WebGL2 Text - Canvas 2D</a>
      <li><a href="/webgl/lessons/webgl-text-texture.html">WebGL2 Text - Using a Texture</a>
      <li><a href="/webgl/lessons/webgl-text-glyphs.html">WebGL2 Text - Using a Glyph Texture</a>
    </ul>
  </ul>
  <li>Misc</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-setup-and-installation.html">WebGL2 Setup And Installation</a></li>
    <li><a href="/webgl/lessons/webgl-boilerplate.html">WebGL2 Boilerplate</a></li>
    <li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">WebGL2 Resizing the Canvas</a></li>
    <li><a href="/webgl/lessons/webgl-animation.html">WebGL2 - Animation</a></li>
    <li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
    <li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">WebGL2 - 2D vs 3D libraries</a></li>
    <li><a href="/webgl/lessons/webgl-anti-patterns.html">WebGL2 - Anti-Patterns</a></li>
  </ul>
</ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="http://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/greggman/webgl2-fundamentals">github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgl2">Ask on stackoverflow</a>.</div>
        <div>Issue/Bug? <a href="http://github.com/greggman/webgl2-fundamentals/issues">Create an issue on github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 What&#x27;s New';
            var disqus_title = 'WebGL2 What&#x27;s New';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-90754717-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



